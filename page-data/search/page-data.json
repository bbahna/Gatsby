{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"왜 등장했을까? HTTP 통신은 요청(Request) → 응답(Response)이 종료되면 연결을 끊어버림 Connectionless(비연결성): 클라이언트가 서버에 요청을 했을 때, 요청에 맞는 응답을 보낸 후 연결을 끊는 처리방식 Stateless(무상태성): 클라이언트의 상태 정보를 가지지 않는 서버 처리방식(클라이언트와 첫 번째 통신에 데이터를 주…","fields":{"slug":"/http-network/"},"frontmatter":{"date":"September 10, 2022","title":"인증방식: 쿠키, 세션, 토큰(JWT)","tags":["http","network","cookie","cache","session","token","JWT","TIL"]},"rawMarkdownBody":"\n## 왜 등장했을까?\n- **HTTP 통신**은 요청(Request) → 응답(Response)이 종료되면 연결을 끊어버림\n  1. **Connectionless**(비연결성**)**: 클라이언트가 서버에 요청을 했을 때, 요청에 맞는 응답을 보낸 후 연결을 끊는 처리방식\n  2. **Stateless**(무상태성**)**: 클라이언트의 상태 정보를 가지지 않는 서버 처리방식<br/>(클라이언트와 첫 번째 통신에 데이터를 주고 받았다 해도, 두 번째 통신에 이전 데이터를 유지하지 않음)\n- 이를 보완하기 위해 쿠키, 세션, 토큰의 인증 방식을 사용\n\n## 쿠키(Cookie)\n- 공개 가능한 정보를 사용자의 브라우저에 저장\n- 보안에 취약함(개인정보를 HTTP로 주고 받는 것은 위험)\n\n### 캐시(Cache)\n- 자주 사용하는 데이터를 미리 복사해두는 임의의 장소\n- 데이터나 값을 미리 복사해 놓음으로써 빠르게 데이터에 접근 가능\n\n## 세션(Session)\n- 클라이언트에 대해 유일한 값(세션 id)를 부여, 세션 스토리지에 세션 정보를 저장\n- 인증정보를 서버에 저장(사용자가 많다면 서버에 부하)\n\n## 토큰(Token)\n### [JWT](https://jwt.io)(JSON Web Token)\n- 인증에 필요한 정보들을 암호화시킨 토큰\n- 쿠키/세션 방식과 유사하게 JWT(Access Token)를 HTTP 헤더에 실어 서버가 클라이언트를 식별\n\n### 구조: Header.payload.signature(. 으로 구분)\n- **Header**: JWT를 어떻게 검증(verify)하는가에 대한 내용\n- **payload**: JWT의 내용(client id 및 유효기간 등)\n- **signature**: 암호화된 Header와 Payload를 더한 뒤 비밀키로 해싱하여 생성\n\n### 장점\n- header와 payload로 signaure를 생성하므로 데이터 위변조를 막을 수 있음\n- 별도의 저장소가 필요없음(서버 부하 ↓)\n- 토큰은 한 번 발급되면 유효기간이 만료 시까지 계속 사용 가능\n\n### 단점\n- 토큰의 길이가 길어 인증 요청이 많아질수록, 네트워크 부하가 심해짐\n- payload 자제는 암호화되지 않기에 중요한 정보를 담으면 안됨\n- 토큰이 유출되면 대처하기 어려움\n- 특정 사용자의 접속을 강제로 만료하기 어려움\n\n### 해결방안\n- **짧은 만료기한 설정**: 만료기한을 짧게 설정해서 유출될 위험을 줄임\n- **Refresh Token**: 클라이언트가 로그인할 때 Access Token 및 Refresh Token을 발급\n- **Sliding Session**: 클라이언트에게 자동으로 토큰 만료 기한을 늘려줌\n"},{"excerpt":"1. ssh key 생성    다음으로 SSH 키에 대한 비밀번호를 추가로 지정할지 물어봅니다. 패스워드를 설정해도 되고, 추가 패스워드 없이 사용하려면 엔터를 두 번 입력해줍니다.\n(추가 패스워드는 나중에 지정하는 것도 가능하지만, GitHub에서는 공식적으로 패스워드 설정을 권장하고 있습니다) 2. ssh config 설정 3. ssh agent 등록…","fields":{"slug":"/git-ssh/"},"frontmatter":{"date":"August 05, 2022","title":"[Git] 한 컴퓨터에서 여러계정 사용하기","tags":["git","ssh","key"]},"rawMarkdownBody":"\n## 1. ssh key 생성\n`$ cd .ssh`\n\n`$ ssh-keygen -t rsa -C \"[hyoon.dev@gmail.com](mailto:hyoon.dev@gmail.com)\" -r \"hyoon\"`\n\n`$ ssh-keygen -t rsa -C \"[lemontree6629@gmail.com](mailto:lemontree6629@gmail.com)\" -r \"linaoo7\"`\n\n- 다음으로 SSH 키에 대한 비밀번호를 추가로 지정할지 물어봅니다. 패스워드를 설정해도 되고, 추가 패스워드 없이 사용하려면 엔터를 두 번 입력해줍니다.<br/>\n  (추가 패스워드는 나중에 지정하는 것도 가능하지만, GitHub에서는 공식적으로 패스워드 설정을 권장하고 있습니다)\n\n```powershell\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\n```\n\n## 2. ssh config 설정\n```powershell\nHost github.com-hyoon\n        HostName github.com\n        User hyoon.dev@email.com\n        IdentityFile ~/.ssh/hyoon\nHost github.com-linaoo7\n        HostName github.com\n        User lemontree6629@email.com\n        IdentityFile ~/.ssh/linaoo7\n```\n\n## 3. ssh agent 등록\n- 개인키 비밀번호 암호화하여 저장\n\n```powershell\n$ ssh-add hyoon\nIdentity added: hyoon (hyoon.dev@email.com)\n\n$ ssh-add linaoo7\nIdentity added: linaoo7 (lemontree6629@email.com)\n\n$ ssh-add -l\n```\n\n## 4. github에 public key 등록\n### 개인키 출력\n`$ cat hyoon.pub\n $ cat linaoo7.pub`\n- [https://github.com/settings/keys](https://github.com/settings/keys) 등록설정\n    ![add new key](git-ssh(1).png)\n    ![ssh key (hyoon)](git-ssh(2).png)\n    ![ssh key (linaoo7)](git-ssh(3).png)\n  1. **리포에 설정하기** : Project Repo → Settings → Deploy Keys → Add Deploy Key> `id_rsa.pub`의 내용 쓰기\n  2. **계정에 설정하기** : 계정 → Settings → SSH and GPG keys → SSH Keys → New SSH Key 선택> `id_rsa.pub`의 내용 쓰기\n\n## 5. ssh로 clone\n![repository-clone(ssh)](git-ssh(4).png)\n"},{"excerpt":"React hooks란?  함수형 컴포넌트에서 기능을 추가할 때 사용하는 함수들 1. useEffect 컴포넌트가 마운트 됐을 때(처음 나타났을 때), 언마운트 됐을 때(사라질 때), 그리고 업데이트 될 때(특정 props가 바뀔 때) 실행되는 hook API 호출, 이벤트 처리 등을 처리할 때 사용 2. useMemo 이전에 계산 한 값(랜더링한 함수 …","fields":{"slug":"/react-hooks/"},"frontmatter":{"date":"June 30, 2022","title":"React hooks에 대해 알아보자","tags":["React","hooks","useEffect","useMemo","useCallback","useRef","useReducer","useState","useContext","portals"]},"rawMarkdownBody":"\n> **React hooks란?** <br/> 함수형 컴포넌트에서 기능을 추가할 때 사용하는 함수들\n\n## 1. useEffect\n - 컴포넌트가 마운트 됐을 때(처음 나타났을 때), 언마운트 됐을 때(사라질 때), 그리고 업데이트 될 때(특정 props가 바뀔 때) 실행되는 hook\n - API 호출, 이벤트 처리 등을 처리할 때 사용\n\n## 2. useMemo\n  - 이전에 계산 한 값(랜더링한 함수 등)을 재사용하게 해줌\n  - 특정 결과값을 재사용 할 때 사용\n  - why? 성능 최적화\n\n## 3. useCallback\n  - 특정 함수를 새로 만들지 않고 재사용하고 싶을 때 사용\n  - useMemo와의 차이? useMemo는 함수를 실행, useCallback은 함수를 반환\n\n## 4. useRef\n  - 특정 DOM 선택, 접근하기 위해서\n  - why? 특정 DOM에 적용하기 때문에 DOM을 선택해야 하는 상황이 발생\n  - 외부 라이브러리 사용할 때 등\n\n## 5. useState\n  - 현재 컴포넌트에서 동적으로 변경되는 상태를 관리\n\n## 6. useReducer\n  - 상태관리, 현재 컴포넌트가 아닌 **다른 곳에 state를 저장하고 싶을 때 유용**\n  - useState와 다르게 컴포넌트 바깥에 작성, 다른 파일에 작성 후 불러와서 사용\n  ### + useState 차이점?\n    - 컴포넌트에서 관리하는 값이 딱 하나고, 그 값이 단순한 숫자, 문자열 또는 boolean 값이라면 확실히 useState로 관리하는게 편할 것\n    - 만약에 컴포넌트에서 관리하는 값이 여러개가 되어서 상태의 구조가 복잡해진다면 useReducer로 관리하는게 편할 것\n\n## 7. useContext\n  - 컴포넌트 간 상태를 전달할 때 사용\n  - props로 전달하기에 코드중첩, 가독성 등 좋지 않음\n  - 중첩 구조가 복잡한 상황에서도 비교적 쉽게 데이터를 전달할 수 있다\n\n## 8. reactDom portal\n  - 부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링하는 기능을 제공 <br/>\n  -> 독립적인 구조를 가질 수 있음. 부모 컴포넌트의 제약에서 벗어날 수 있음. 왜? react 트리구조를 가지고 있기 때문에.\n  [공식문서](https://ko.reactjs.org/docs/portals.html)\n\n## +useSelector, useDispatch, useStore\n  - [redux 관련 hook](https://react-redux.js.org/api/hooks)\n  \n"},{"excerpt":"React 특징 JavaScript Frontend Framework(Library) 사용자 인터페이스를 구축하기 위한 선언적이고 효율적이며 유연한 JavaScript 라이브러리\n“컴포넌트”라고 불리는 작고 고립된 코드의 파편을 이용하여 복잡한 UI를 구성하도록 돕습니다. SPA(Single Page Application) Component 기반 Virt…","fields":{"slug":"/why-react/"},"frontmatter":{"date":"June 20, 2022","title":"React.js는 왜 쓸까?","tags":["React","component","TIL"]},"rawMarkdownBody":"\n## [React](https://ko.reactjs.org/) 특징\nJavaScript Frontend Framework(Library)\n> 사용자 인터페이스를 구축하기 위한 선언적이고 효율적이며 유연한 JavaScript 라이브러리<br/>\n> “컴포넌트”라고 불리는 작고 고립된 코드의 파편을 이용하여 복잡한 UI를 구성하도록 돕습니다.\n- SPA(Single Page Application)\n- Component 기반\n- [Virtual DOM](https://react.vlpt.us/basic/01-concept.html)\n- [JSX](https://ko.reactjs.org/docs/introducing-jsx.html)(JavaScript XML)\n\n## CRA로 프로젝트 생성\n`$ npx create-react-app {project-name}`<br/>\n`$ yarn create react-app {project-name}`\n\n## 상태관리\n- react-hook\n- redux\n- recoil\n"},{"excerpt":"git commit history 전부 삭제하기 clone 후 기존 git commit history를 reset 후 새로운 commit history를 남기고 싶을 때 사용하면 됩니다. warning: 이 방법을 사용하면 기존 커밋 히스토리가 전부 reset(초기화) 됩니다. 1. commit history 삭제 2. git 재설정 3. git 커밋 4…","fields":{"slug":"/git-history/"},"frontmatter":{"date":"June 10, 2022","title":"[Git] commit history 초기화","tags":["git","commit","history"]},"rawMarkdownBody":"\n## git commit history 전부 삭제하기\n\n>clone 후 기존 git commit history를 reset 후 새로운 commit history를 남기고 싶을 때 사용하면 됩니다.\n\n* warning: 이 방법을 사용하면 기존 커밋 히스토리가 전부 reset(초기화) 됩니다.\n\n### 1. commit history 삭제\n```\n$ rm -rf .git\n```\n### 2. git 재설정\n```\n$ git init\n```\n### 3. git 커밋\n```\n$ git add .\n$ git commit -m \"initial commit\"\n```\n### 4. git 원격 저장소 연결\n```\n$ git remote add origin [저장소 URL]\n```\n### 5. git 원격 저장소 푸시 *(force: 기존 자료로 발생하는 에러를 무시한 강한 규칙 적용)*\n```\n$ git push -u --force origin master\n```\n작업이 완료되면 해당 리포지토리에 처음 commit된 상태로 파일이 업로드 된 것을 확인 가능합니다.\n"},{"excerpt":"Node.js란 chrome의 JavaScript 해석엔진 V8로부터 개발된 JavaScript 런타임(실행) 환경 nvm(node version management) npm(node package management) yarn Node.js를 쓰는 이유 non-blocking I/O 코드가 짧고 쉬움 blocking: 요청받은 함수 작업을 모두 마쳐야 …","fields":{"slug":"/why-nodejs/"},"frontmatter":{"date":"May 30, 2022","title":"JavaScript 런타임 환경 Node.js","tags":["node.js","nvm","npm","yarn","TIL"]},"rawMarkdownBody":"\n## Node.js란\nchrome의 JavaScript 해석엔진 [V8](https://v8.dev/)로부터 개발된 JavaScript 런타임(실행) 환경\n- nvm(node version management)\n- npm(node package management)\n- yarn\n\n## Node.js를 쓰는 이유\n- non-blocking I/O\n- 코드가 짧고 쉬움\n\n> **blocking**: 요청받은 함수 작업을 모두 마쳐야 제어권을 넘겨줌 (그동안 요청자는 기다림)\n> \n> **non-blocking**: 요청받은 함수가 요청자에게 제어권을 바로 넘겨줌 (그동안 요청자는 다른 일을 할 수 있음)\n>\n> ⇒ 요청받은 함수가 제어권(함수실행권)을 언제 넘겨주냐\n> \n> <br/>\n> \n> **Syncronous**(동기): 요청자가 요청받은 함수의 작업이 완료되었는지 계속 확인\n> \n> **Asynchronous**(비동기): 요청자는 요청 후 신경쓰지 않음, 요청받은 함수가 작업을 마치면 알려줌\n>\n> ⇒ 요청받은 함수의 작업완료 여부를 누가 체크하느냐\n\n## [Node 버전](https://nodejs.org/ko/) - LTS, Current\n![nodejs.org](why-nodejs(1).png)\n\n### LTS ‘안정적, 신뢰도 높음’\n- Long Term Support\n- 오랜기간 지원이 가능한\n- 해당 버전에 대한 취약점 및 개선사항에 대한 패치를 2년간 보증하는 버전\n\n### Current ‘최신 기능’\n- 아직 개발이 진행 중인 버전\n"},{"excerpt":"Clone(클론) 원격 저장소를 로컬 저장소에 복제\n Branch(브랜치) 동시에 다양한 작업을 할 수 있도록 분리된 작업영역 브랜치 생성\n 브랜치 삭제\n Checkout(체크아웃) 브랜치 전환\n 브랜치 생성과 전환\n 브랜치 조회\n Commit(커밋) 커밋 추가\n\n 커밋 상태\n 커밋 메시지\n Push(푸시) 원격 저장소의 데이터를 로컬 저장소에 가져와 병…","fields":{"slug":"/git-basic/"},"frontmatter":{"date":"May 20, 2022","title":"[Git] 기본 명령어들","tags":["git","commit","push","pull","TIL"]},"rawMarkdownBody":"\n## Clone(클론)\n- 원격 저장소를 로컬 저장소에 복제<br/>\n    `$ git clone https://github.com/{GithubID}/{RepositoryName}.git`\n    \n## Branch(브랜치)\n동시에 다양한 작업을 할 수 있도록 분리된 작업영역\n- 브랜치 생성<br/>\n    `$ git branch {브랜치 이름}`\n    \n- 브랜치 삭제<br/>\n    `$ git branch -D {브랜치 이름}`\n    \n## Checkout(체크아웃)\n- 브랜치 전환<br/>\n    `$ git checkout {브랜치 이름}`\n    \n- 브랜치 생성과 전환<br/>\n    `$ git branch -b {브랜치 이름}`\n    \n- 브랜치 조회<br/>\n    `$ git branch`\n    \n## Commit(커밋)\n- 커밋 추가<br/>\n    `$ git add .`<br/>\n    `$ git add {파일명}`\n    \n- 커밋 상태<br/>\n    `$ git status`\n    \n- 커밋 메시지<br/>\n    `$ git commit -m \"커밋 메시지\"`\n    \n## Push(푸시)\n- 원격 저장소의 데이터를 로컬 저장소에 가져와 병합하기<br/>\n    `$ git push {origin master}`\n    \n## Fetch(패치)\n- 원격 저장소의 데이터를 로컬에 가져오기만 하기<br/>\n    `$ git fetch {origin master}`\n    \n## Pull(풀)\n- 로컬 저장소의 데이터를 원격 저장소로 밀어넣기<br/>\n    `$ git pull {origin master}`\n\n## Merge(머지)\n- 변경 이력 병합하기<br/>\n    `$ git merge {branch_name}`\n    \n## Tag(태그)\n- 커밋을 참조하기 쉽도록 알기 쉬운 이름을 붙이는 것<br/>\n    `$ git tag {태그 이름}`\n\n- 태그명으로 커밋 조회<br/>\n    `$ git show {태그 이름}`\n"},{"excerpt":"CSR(Client Side Rendering) 최초에 한번 서버에서 전체 페이지를 로딩하여 보여주고, 이후에는 클라이언트의 요청이 올 때 리소스를 서버에서 제공한 후, 클라이언트가 해석하고 렌더링함 모든 html과 static 파일이 로드될 때까지 기다려야 함 SEO(검색 엔진 최적화)가 어려움 SSR(Server Side Rendering) 완전한 h…","fields":{"slug":"/application-rendering/"},"frontmatter":{"date":"May 10, 2022","title":"CSR, SSR / SPA, MPA에 대한 이해","tags":["CSR","SSR","SPA","MPA","TIL"]},"rawMarkdownBody":"\n## CSR(Client Side Rendering)\n최초에 한번 서버에서 전체 페이지를 로딩하여 보여주고, 이후에는 클라이언트의 요청이 올 때 리소스를 서버에서 제공한 후, 클라이언트가 해석하고 렌더링함\n- 모든 html과 static 파일이 로드될 때까지 기다려야 함\n- SEO(검색 엔진 최적화)가 어려움\n\n## SSR(Server Side Rendering)\n완전한 html 파일을 받아오고, 웹 서버에 요청할 때마다 브라우저 새로고침이 일어나고 서버에서 새로운 페이지를 렌더링함\n- 초기 로딩 속도가 빠르고 모든 검색 엔진에 대한 SEO가 가능\n- 매번 페이지를 요청할 때마다 서버에 요청하기에 트래픽, 서버 부하가 있음\n> **SEO(search engine optimization, 검색 엔진 최적화)**\n> \n> 웹 페이지 검색엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성해서 검색 결과의 상위에 나올 수 있도록 하는 작업\n---\n\n## MPA(Multiple Page Application)\n모든 페이지는 각각의 **html**으로 이루어지고, 페이지가 바뀔 때마다 매번 완전한 페이지를 응답으로 받음\n- 직관적이며 SEO에 대해 고민하지 않아도 됨\n- 필요한 부분만 응답으로 받는 방식에 비해 비효율적, 페이지가 바뀔 때 브라우저가 깜빡임\n\n## SPA(Single Page Application)\n처음엔 **하나의 페이지**(html) 불러오고, 클라이언트의 요청이 있을 때 관련 컴포넌트를 불러옴\n- 화면이 깜빡이지 않는 자연스러운 화면전환\n- SPA는 화면을 띄우는데 js가 사용되고, SEO를 위한 웹 크롤러는 대부분 js를 해석하지 못하기에 SEO에 불리함\n\n<aside>\n⚠️ SPA 방식이 모두 CSR인 것은 아니다\n</aside>\n"},{"excerpt":"기술 블로그로 Gatsby를 선택한 후, 서버 배포에 대해 고민하다 github-page를 이용하여 배포하기로 하였습니다.\ngithub와 연동이 되며 사용법이 어렵지 않다는 장점으로 선택하게 되었습니다. 1. github-page repository 생성 repository name: \n 2. gatsby template 선택 gatsby template…","fields":{"slug":"/github-page/"},"frontmatter":{"date":"May 01, 2022","title":"Gatsby 개발기록 _github page 배포설정","tags":["github","build","cicd","TIL"]},"rawMarkdownBody":"\n&nbsp;기술 블로그로 **Gatsby**를 선택한 후, 서버 배포에 대해 고민하다 **github-page를 이용하여 배포**하기로 하였습니다.<br />\n**github와 연동**이 되며 **사용법이 어렵지 않다**는 장점으로 선택하게 되었습니다.\n\n## 1. github-page repository 생성\n- repository name: `계정.github.io`\n  ![](github-page(1).png)\n\n## 2. gatsby template 선택\n- gatsby template는 [gatsby-starter-hoodie](https://github.com/devHudi/gatsby-starter-hoodie) 결정\n\n> **나의 template 선택조건**\n> - 다크모드, 검색, 태그, 댓글기능\n\n추가로 [gatsby-starter-bee](https://github.com/JaeYeopHan/gatsby-starter-bee), [gatsby-starter-apple](https://github.com/sungik-choi/gatsby-starter-apple)도 마지막까지 고민한 템플릿입니다.<br/>\n공식 홈페이지에서도 [template](https://www.gatsbyjs.com/starters/)를 제공하고 있습니다.\n\n## 3. gatsby template clone\n- gatsby cli 설치<br/>\n    `$ npm install -g gatsby-cli`<br/>\n    `$ yarn global add gatsby-cli`\n    \n- project 생성<br/>\n    `$ gatsby new {project-name} {template-route}`<br/>\n    `$ gatsby new bbahna.github.io https://github.com/devHudi/gatsby-starter-hoodie`\n    \n- 개발 설정<br/>\n    `$ cd bbahna.github.io`<br/>\n    `$ npm install`<br/>\n    `$ gatsby develop` 또는 `$ yarn develop`\n    \n- git 연결<br/>\n    `$ rm -rf .git`<br/>\n    `$ git init`<br/>\n    `$ git remote add origin https://github.com/bbahna/bbahna.github.io.git`\n    \n- 원격 저장소에 소스 올리기<br/>\n    `$ git add .`<br/>\n    `$ git commit -m “init”`<br/>\n    `$ git push origin master`\n\n## 4. customizing\n- [blog-config.js 수정](https://github.com/bbahna/bbahna.github.io/blob/master/blog-config.js)\n- favicon, profile, link image 변경\n\n## 5. github page **호스팅**\n- gh-pages 설치<br/>\n    `$ npm i gh-pages`<br/>\n    `$ yarn add gh-pages --dev`\n\n## 6. **github actions** 배포 자동화(CI/CD)\n### [token 발급](https://github.com/settings/tokens)\n- [자동 build token 설정](https://github.com/bbahna/bbahna.github.io/commit/01b0684c08700088b8c2b152bb9662c5b913a3ef)\n    - .[github/workflows/ci.yml](https://github.com/bbahna/bbahna.github.io/blob/master/.github/workflows/ci.yml)\n        ```json\n        with:\n        \taccess-token: ${{ secrets.BBAHNA_TOKEN }}\n        \tdeploy-branch: gh-pages\n        ```\n        \n- [Create main.yml](https://github.com/bbahna/bbahna.github.io/commit/759b0a9bb288a4e5f8847f4f46fddb49320752f3)\n    - [.github/workflows/main.yml](https://github.com/bbahna/bbahna.github.io/blob/master/.github/workflows/main.yml)\n        ```json\n        access-token: ${{ secrets.BBAHNA_TOKEN }}\n        ```\n        \n- 새글 생성\n    - contents/posts/post-name/index.md<br/>\n        _**url: bbahna.gitbhub.io/post-name**_\n\n- [Action](https://github.com/bbahna/bbahna.github.io/actions) 확인\n\n### Gatsby 배포특징\n- 가공할 정보를 GraphQL에서 가져와서 **Build 과정에서 마크업 생성**\n- 배포할 때 각 페이지 정보들이 모두 만들어지므로 따로 서버가 필요하지 않다.<br/>\n    ↔ SPA(Single Page Application): JavaScript가 실행되면 빈 HTML 페이지 안에 마크업을 추가\n\n### **검색엔진 최적화\n - 추후 업데이트 예정 :)\n"},{"excerpt":"Gatsby는 JAM Stack을 활용한 정적 사이트 생성 프레임워크 JAM Stack?  : JavaScript : API : Markup JavaScript, API, HTML이나 CSS 등을 칭하는 MarkUp으로 웹 애플리케이션을 구성하는 스택 Jamstack is an architecture designed to make the web faste…","fields":{"slug":"/js-framework/"},"frontmatter":{"date":"April 30, 2022","title":"기술 블로그에 Gatsby를 사용한 이유","tags":["Gatsby","Next","Nuxt","JAMStack","TIL"]},"rawMarkdownBody":"\n**Gatsby**는 **JAM Stack을 활용한 정적 사이트 생성 프레임워크**\n\n## JAM Stack?\n![](js-framework(1).png)\n- **`J`**: JavaScript\n- **`A`**: API\n- **`M`**: Markup\n\n**JavaScript, API,** HTML이나 CSS 등을 칭하는 **MarkUp**으로 웹 애플리케이션을 구성하는 스택\n\n> **Jamstack is an architecture designed to make the web faster, more secure, and easier to scale.**\n> \n> JAM Stack 은 더 빠르고, 안전하며, 스케일링하기 쉬운 웹을 만들기 위해 디자인된 아키텍처입니다.\n\n## JAM Stack 기반 프레임워크\n- next, gatsby, nuxt, jekyll..\n\n## JAM Stack 동작원리\n![](js-framework(2).png)\n- **Traditional Web**: server DB 또는 CMS(Content Management System)에서 추출한 데이터를 프론트엔드에 뿌려주는 방식 ⇒ 구조가 복잡함\n- **JAM Stack**: CDN(Content Delivery Network)\n\n## **JAM Stack 장점**\n### 1. **더 빠르게 웹 사이트를 제공할 수 있음**\n![](js-framework(3).png)\n\n### 2. **안전한 웹 사이트를 제공할 수 있음**\n![](js-framework(4).png)\n\n### 3. **스케일링하기 쉬운 웹 사이트를 제공할 수 있음**\n![](js-framework(5).png)\n`data scaling 데이터 전처리`\n\n## Blog project에 Gatsby를 선택한 이유\n- 현재시점 가장 많은 다운로드가 있는 **Next**는 서버 사이드 렌더링(SSR) 프레임워크에 가까우며,\n\n    컨텐츠의 변화가 잦지 않은 블로그에는 정적 사이트 생성에는 **Gatsby**가 적합하다고 판단\n- +**React 기반**이며 **custom**이 어렵지 않음\n"},{"excerpt":"HTML이란 HTML(HyperText Markup Language)은 웹을 이루는 가장 기초적인 구성 요소로, 웹 콘텐츠의 의미와 구조를 정의할 때 사용한다. HTML 이외의 다른 기술은 일반적으로 웹 페이지의 모양/표현 (CSS), 또는 기능/동작 (JavaScript)을 설명하는 데 사용된다. DOM이란 “Document(HTML)에 접근해서, Ob…","fields":{"slug":"/html-dom/"},"frontmatter":{"date":"April 20, 2022","title":"HTML, DOM 차이","tags":["HTML","DOM","TIL"]},"rawMarkdownBody":"\n## HTML이란\n- **HTML(**HyperText Markup Language)은 웹을 이루는 가장 기초적인 구성 요소로, 웹 콘텐츠의 의미와 구조를 정의할 때 사용한다.\n- HTML 이외의 다른 기술은 일반적으로 웹 페이지의 모양/표현 ([CSS](https://developer.mozilla.org/ko/docs/Web/CSS)), 또는 기능/동작 ([JavaScript](https://developer.mozilla.org/ko/docs/Web/JavaScript))을 설명하는 데 사용된다.\n\n## DOM이란\n- “**Document**(HTML)에 접근해서, **Object**(Javascript)처럼 HTML을 조작(Manipulation) 할 수 있는 **Model**”\n- DOM은 HTML과 스크립팅 언어(Javascript)를 서로 이어주는 역할\n- **즉, 우리가 js를 다룰 수 있으면, DOM을 활용해서 HTML을 조작할수 있다는 의미이다.**\n\n> **Virtual DOM?**\n> Virtual DOM(가상돔)을 사용하면 실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용\n\n## HTML, DOM 차이\n- 브라우저는 HTML페이지를 로드하면서, ’HTML태그의 포함관계에 따라 DOM객체들을 트리구조’로 만든다. -> DOM트리\n- JS코드는 DOM트리를 따라, DOM객체들을 마음대로 접근할 수 있고 HTML 요소를 JS의 Object처럼 조작할 수 있다.\n- DOM을 다뤄 HTML을 단순한 문서에서 웹 앱으로 업그레이드 할 수 있다.\n"},{"excerpt":"자바스크립트란 ‘웹페이지(HTML)에 생동감을 불어넣기 위해’ 만들어진 프로그래밍 언어입니다. 오늘날 자바스크립트는 브라우저 환경에서 가장 널리 사용되는 언어이며, 자바스크립트는 브라우저뿐만 아니라 서버에서도 실행할 수 있습니다. 이 외에도 자바스크립트 엔진(JavaScript engine)이라 불리는 특별한 프로그램이 들어 있는 모든 디바이스에서도 동작…","fields":{"slug":"/javascript-engine/"},"frontmatter":{"date":"April 10, 2022","title":"JavaScript 엔진(V8, Spider Monkey)","tags":["JavaScript","engine","V8","SpiderMonkey","TIL"]},"rawMarkdownBody":"\n## 자바스크립트란\n- ‘웹페이지(HTML)에 생동감을 불어넣기 위해’ 만들어진 프로그래밍 언어입니다.\n- 오늘날 자바스크립트는 브라우저 환경에서 가장 널리 사용되는 언어이며, 자바스크립트는 브라우저뿐만 아니라 서버에서도 실행할 수 있습니다.\n- 이 외에도 [자바스크립트 엔진(JavaScript engine)](https://en.wikipedia.org/wiki/JavaScript_engine)이라 불리는 특별한 프로그램이 들어 있는 모든 디바이스에서도 동작합니다.\n- 브라우저엔 '자바스크립트 가상 머신’이라 불리는 엔진이 내장되어 있습니다.\n\n## 브라우저 내 자바스크립트 엔진 종류\n- Chrome, Opera - [V8](https://en.wikipedia.org/wiki/V8_(JavaScript_engine))\n- Firefox - [SpiderMonkey](https://en.wikipedia.org/wiki/SpiderMonkey)\n- Edge - ChakraCore\n- Safari - SquirrelFish\n\n## 자바스크립트만의 장점\n- HTML/CSS와 완전히 통합할 수 있음\n- 모든 주요 브라우저에서 지원하고, 기본 언어로 사용됨\n- 간단한 일은 간단하게 처리할 수 있게 해줌\n\n## 호환성 표\n자바스크립트 메서드/함수 관련정보, 브라우저 지원여부 확인\n- [자바스크립트 해당 기능을 특정 엔진이 지원하는지](https://kangax.github.io/compat-table/es6/)\n- [브라우저가 특정 기능을 지원하는지](https://caniuse.com/)\n\n> 참고문서\n> - [JavaScript engine-wiki](https://en.wikipedia.org/wiki/JavaScript_engine)\n> - [자바스크립트 튜토리얼](https://ko.javascript.info/intro)\n"},{"excerpt":"1. 웹 브라우저 동작원리 입력한 사이트의 서버로부터 index.html을 가져오며 html 파일에 종속된 파일(js, css, image 등)을 만날 때마다 서버로 를 보내 받아온다.\n 웹 클라이언트 필요한 파일들(html,js,css...)을 다운받아 해석(렌더링)하여 사용자에게 보여주는 프로그램(브라우저) 웹 서버 클라이언트의 요청(url)에 따라 …","fields":{"slug":"/web-http/"},"frontmatter":{"date":"April 03, 2022","title":"웹 브라우저 동작원리, http란?","tags":["web","browser","http","TIL"]},"rawMarkdownBody":"\n## 1. 웹 브라우저 동작원리\n입력한 사이트의 서버로부터 index.html을 가져오며 **html 파일에 종속된** 파일(js, css, image 등)을 만날 때마다 서버로 `http request`를 보내 받아온다.\n![overview](web-http(1).png)\n\n### 웹 클라이언트\n필요한 파일들(html,js,css...)을 다운받아 해석(렌더링)하여 사용자에게 보여주는 프로그램(브라우저)\n\n### 웹 서버\n클라이언트의 요청(url)에 따라 응답(response)해주는 프로그램\n- 프론트 서버: 정적 or 동적인 페이지를 응답하기 위한 서버. 웹 구성요소(html, css, js) 응답 등.\n    - 웹이 비대해지면 서버의 역할 분담, 보안을 위해 `WAS` 와 `프론트 서버`로 나누기도 한다.\n- 백엔드 서버: 사용자의 요청을 받았을 때 DB에서 적절한 데이터를 가져와 응답하기 위한 서버\n\n### DB\n사용자의 목록, 정보 등 중요한 데이터들이 저장된 저장소\n\n---\n## 동작원리\n1. 주소창에 url(ex: 구글) 입력\n2. 구글 서버로 찾아감\n3. *DNS가 연결해줄 곳을 찾음    \n    > **도메인 이름 시스템(Domain Name System)**\n    [IP](https://namu.wiki/w/IP) 네트워크에서 사용하는 시스템. 영문/한글 주소를 IP 네트워크에서 찾아갈 수 있는 [IP](https://namu.wiki/w/IP)로 변환해줌.\n    > \n4. 구글 서버에서 HTML 파일을 클라이언트로 보냄.\n5. 서버로 부터 받은 HTML(Document Object Model) 파일 파싱 및 DOM Tree 생성 (브라우저 역할)\n    ![DOM Tree](web-http(2).png)\n6. CSS 파싱 및 CSSOM(CSS Object Model) Tree 생성    \n    ![CSSOM Tree](web-http(3).png)\n    \n7. DOM, CSSOM 합쳐 Render Tree 생성    \n    ![Render Tree](web-http(4).png)  \n    Render Tree에는 실제 화면에 표현되는 노드(요소)들로만 구성됨    \n    ex) `display : none` 속성이 설정된 요소는 Render Tree를 만드는 과정에서 제외됨<br/>\n    `visibility : invisible` 속성은 공간은 차지하고 요소가 보이지 않게 하기에 Render Tree에 포함    \n8. JavaScript를 만나면? HTML 파서는 JS 코드를 실행하기 위해 파싱 중단\n9. JS 엔진 실행 및 JS 코드 파싱\n\n---\n## 2. http란?\n- Hyper Text Transfer Protocol의 약자\n- 인터넷에서 데이터를 주고받을 수 있는 프로토콜(통신규약)\n- 웹에서 모든 데이터 교환의 기초\n- 규칙을 정해두었기 때문에, 모든 프로그램이 이 규칙에 맞춰 개발하여 정보교환을 함\n    - 클라이언트 ⇒ 서버 : request(요청)\n    - 서버 → 클라이언트 : respnse(응답)\n\n### http요청\n- 읽기(GET)\n- 쓰기(POST)\n- 수정(PUT)\n- 삭제(DELETE)\n\n### 응답코드\n - 추후 업데이트 예정 :)\n"},{"excerpt":"","fields":{"slug":"/who-is/"},"frontmatter":{"date":"April 01, 2022","title":"🧐 Who is hyoon?","tags":["hyoon","blog","about"]},"rawMarkdownBody":"\n```jsx\nexport const hyoon = {\n  name: 'yoon hyoJeong',\n  role: 'Web ui/ux design & Frontend develop',\n  github: 'github.com/bbahna',\n  blog: 'bbahna.github.io',\n  email: 'hyoon.dev@gmail.com',\n  skill: ['JavaScript', 'TypeScript', 'React', 'Gatsby', ...],\n}\n```\n<h5 align=\"center\">\n안녕하세요. 프론트엔드 웹 개발을 배우며 기록합니다.<br/>\n사용자의 UI/UX을 통한 비즈니스 가치 구현을 추구합니다.\n</h5>\n"},{"excerpt":"bbahna gatsby tech-blog는  gatsby-starter-hoodie template를 커스텀 하였습니다. JAM stack (SEO) - Gatsby template: 반응형, 다크모드, 커스텀, 검색기능, 태그 repository 생성 github page 배포 post build test (자동배포 테스트) customizing bl…","fields":{"slug":"/about-blog/"},"frontmatter":{"date":"March 31, 2022","title":"👀 About bbahna?","tags":["gatsby","blog","about"]},"rawMarkdownBody":"\n> **[bbahna] gatsby tech-blog**는  [gatsby-starter-hoodie](https://github.com/devHudi/gatsby-starter-hoodie) template를 커스텀 하였습니다.\n\n- JAM stack (SEO) - Gatsby\n- template: 반응형, 다크모드, 커스텀, 검색기능, 태그\n- repository 생성\n- github page 배포\n- post build test (자동배포 테스트)\n- customizing\n\n_blog) ui, content 등 업데이트~ing_\n"}]}},"pageContext":{}},"staticQueryHashes":[]}